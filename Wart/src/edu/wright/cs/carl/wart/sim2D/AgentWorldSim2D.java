
package edu.wright.cs.carl.wart.sim2D;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import edu.wright.cs.carl.wart.agent.Agent;
import edu.wright.cs.carl.wart.agent.AgentWorld;

import edu.wright.cs.carl.net.message.payload.ContextViewUpdate;

import edu.wright.cs.carl.wart.sim2D.models.collision.CollisionConstants;

import edu.wright.cs.carl.wart.sim2D.objects.*;

import edu.wright.cs.carl.wart.sim2D.visualization.DrawableObjectSim2D;
import edu.wright.cs.carl.wart.sim2D.visualization.Sim2DGraphicsUpdate;
import edu.wright.cs.carl.wart.sim2D.visualization.Sim2DGraphicsInitializer;


/**
 * A simulated world.  View updates consist of updated information about the
 * various objects in the "world" (e.g., robots, obstacles, movable objects) so
 * that the main view panel can be drawn by the remote clients, as well as
 * any additional information that's needed to update other panels in the
 * SimAgentContextViewPanel.
 * 
 * @author  Duane Bolick
 */
public class AgentWorldSim2D implements AgentWorld, Runnable
{
    //
    // The update thread fields.
    //
    private Thread updateThread;
    private long updateDurationInMillis;
    private boolean stopRequested = false;
    private boolean initialized = false;
    
    //
    // This Map contains all the objects in the world.  It is the "master" list
    // of all objects.
    //    
    private Map<String, ObjectSim2D> objects;
    
    //
    // These Lists contain duplicate references to several different "classes"
    // of objects, based on their collision activity.  These Lists are used by
    // the collision-handling methods as rough "priorities" for who-moves-who
    // in the case of collisions.
    //
    private Map<String, ObjectSim2D> immovable;
    private Map<String, ObjectSim2D> agents;
    private Map<String, ObjectSim2D> movable;
            
    //
    // This List contains the IDs of the outer walls.  Outer walls are "special"
    // in that we have to automatically replace them whenever we resize, so
    // we want to keep a handy way of getting to them.
    //
    List<String> outerWallIDs;    
    
    //
    // The world is a square, this field is its width and height.
    //
    private int worldDimensionInPixels;
    
    private boolean isReady;
    
    /**
     * Constructors.
     */
    
    /**
     * Construct a new, empty sim world with the default dimension, with outer
     * walls.
     */
    public AgentWorldSim2D()
    {
        this.worldDimensionInPixels = ConstantsSim2D.DefaultWorldWidthInPixels;
        this.updateDurationInMillis = 1000 / ConstantsSim2D.DefaultUpdatesPerSecond;
        
        this.objects = new HashMap<String, ObjectSim2D>();
        this.immovable = new HashMap<String, ObjectSim2D>();
        this.agents = new HashMap<String, ObjectSim2D>();
        this.movable = new HashMap<String, ObjectSim2D>();
        this.outerWallIDs = new ArrayList<String>();

        this.setOuterWalls();
    }
    
    /**
     * Create a sim world from an existing map.  First, the outer walls will be
     * created using the provided dimensions.  Then the objects will be added to
     * the world in the order obtained by the <i>Iterator</i> generated by
     * <i>objects</i>, using this class's <i>addObjectSim2D</i> method.
     * 
     * @param   objects                 [in]    Supplies a list of the objects
     *                                          in this world.
     * @param   worldDimensionInPixels  [in]    Supplies the world dimensions.
     */
    public AgentWorldSim2D(List<ObjectSim2D> objects, int worldDimensionInPixels)
    {    
        this.worldDimensionInPixels = worldDimensionInPixels;
        this.updateDurationInMillis = 1000 / ConstantsSim2D.DefaultUpdatesPerSecond;
        
        if(worldDimensionInPixels < ConstantsSim2D.MinWorldWidthInPixels || worldDimensionInPixels > ConstantsSim2D.MaxWorldWidthInPixels) {
            this.worldDimensionInPixels = ConstantsSim2D.DefaultWorldWidthInPixels;
        }               
        
        this.objects = new HashMap<String, ObjectSim2D>();
        this.immovable = new HashMap<String, ObjectSim2D>();
        this.agents = new HashMap<String, ObjectSim2D>();
        this.movable = new HashMap<String, ObjectSim2D>();
        this.outerWallIDs = new ArrayList<String>();

        this.setOuterWalls();
        
        Iterator<ObjectSim2D> it = objects.iterator();
        {
            this.addObjectSim2D(it.next());
        }
    }
    
    
    /**
     * World manipulation methods.
     */
    
    /**
     * See if the world is ready.
     * 
     * @return  True if ready false if not ready.
     */
    public boolean isReady()
    {
        return this.isReady;
    }
    
    /**
     * Set the ready status of this world.
     * 
     * @param   isReady [in]    Supplies if the world is ready.
     */
    public void setIsReady(boolean isReady)
    {
        this.isReady = isReady;
    }    
    
    /**
     * Get all the non-outer-wall objects.
     * 
     * @return  A list of all non-outer-wall objects.
     */
    public List<ObjectSim2D> getAllObjects()
    {
        List<ObjectSim2D> allWorldObjects = new ArrayList<ObjectSim2D>();
        ObjectSim2D currentObject = null;
        Iterator<ObjectSim2D> it = this.objects.values().iterator();
        while(it.hasNext()) {
            currentObject = it.next();
            if(this.outerWallIDs.contains(currentObject.getID()) == false) {
                allWorldObjects.add(currentObject);
            }
        }
        return allWorldObjects;
    }
    
    public ObjectSim2D getObjectAtPoint(Point2D point)
    {
        Iterator<ObjectSim2D> it = this.objects.values().iterator();
        ObjectSim2D currentObject = null;
        while(it.hasNext()) {
            currentObject = it.next();
            if(currentObject.getBoundingBox().contains(point)) {
                return currentObject;
            }
        }
       
        return null;
    }
    
    public ObjectSim2D getObjectByID(String objectID)
    {
        return this.objects.get(objectID);
    }
    
    public List<Agent> getAgents()
    {
        List<Agent> agentList = new ArrayList<Agent>();
        
        Iterator<ObjectSim2D> it = this.agents.values().iterator();
        while(it.hasNext()) {
            agentList.add((Agent)it.next());
        }
        
        return agentList;
    }
    
    /**
     * Add a new object to the world.  If it does not fit inside the current
     * world dimensions, it will be moved towards the origin until it does.
     * Once the object has been moved so that it fits within the world, any
     * resulting collisions will be resolved.
     * 
     * @param   removedObject   [in]    Supplies the new object.
     */
    public synchronized void addObjectSim2D(ObjectSim2D newObject)
    {
        //
        // If the object has either a null or empty ID, provide it a UUID.
        //
        if(newObject.getID() == null || newObject.getID().isEmpty()) {
            newObject.setID(UUID.randomUUID().toString());
        }
        
        //
        // Add the object to the master object Map.
        //
        if(this.objects.containsKey(newObject.getID())) {
            throw new AssertionError("AgentWorldSim2D.addObjectSim2D: There is already an object with this ID.");
        }
        this.objects.put(newObject.getID(), newObject);
        
        //
        // Add the object to the appropriate collision Map.
        //
        if(newObject instanceof RectangularObstacleSim2D || newObject instanceof LightSim2D) {
            this.immovable.put(newObject.getID(), newObject);
        }
        else if(newObject instanceof AgentSim2D) {
            this.agents.put(newObject.getID(), newObject);
        }        
        else {
            this.movable.put(newObject.getID(), newObject);
        }

        
        //
        // If the object isn't within the bounds of the world, move it inward.
        //
        Rectangle2D objectBoundingBox = newObject.getBoundingBox();
        double lrcX = (double) objectBoundingBox.getMaxX();
        double lrcY = (double) objectBoundingBox.getMaxY();
       
        double dx = this.worldDimensionInPixels - lrcX;
        double dy = this.worldDimensionInPixels - lrcY;
        
        AbsolutePositionSim2D adjustedPosition = new AbsolutePositionSim2D();
        adjustedPosition.angleInRadians = newObject.getAbsolutePosition().angleInRadians;
        adjustedPosition.coordinates.x = newObject.getAbsolutePosition().coordinates.x;
        adjustedPosition.coordinates.y = newObject.getAbsolutePosition().coordinates.y;
        
        if(dx < 0) {
            adjustedPosition.coordinates.x += dx;
        }
        
        if(dy < 0) {
            adjustedPosition.coordinates.y += dy;
        }
        
        newObject.setAbsolutePosition(adjustedPosition);
        
        //
        // Now resolve any collisions.
        //
        this.relax();
    }
    
    /**
     * Remove an object from the world.
     * 
     * @param   objectID    [in]    Supplies the object's ID.
     */
    public synchronized ObjectSim2D removeObjectSim2D(String objectID)
    {
        ObjectSim2D removedObject = this.objects.remove(objectID);
        
        if(removedObject == null) {
            throw new AssertionError("AgentWorldSim2D.removeObjectSim2D: There is no object with this ID.");
        }
        
        if(removedObject instanceof RectangularObstacleSim2D || removedObject instanceof LightSim2D) {
            this.immovable.remove(removedObject.getID());
        }
        else if(removedObject instanceof AgentSim2D) {
            this.agents.remove(removedObject.getID());
        }        
        else {
            this.movable.remove(removedObject.getID());
        }
        
        return removedObject;
    }
    
    public void resetWorld()
    {
        this.worldDimensionInPixels = ConstantsSim2D.DefaultWorldWidthInPixels;

        this.objects = new HashMap<String, ObjectSim2D>();
        this.immovable = new HashMap<String, ObjectSim2D>();
        this.agents = new HashMap<String, ObjectSim2D>();
        this.movable = new HashMap<String, ObjectSim2D>();
        this.outerWallIDs = new ArrayList<String>();
        
        this.setOuterWalls();        
    }
    
    /**
     * Resize the dimensions of this sim world.  On an increase in size, all
     * objects will remain in the same position, relative to the upper-left
     * corner of the coordinate plane.  On a decrease in size, any objects that
     * are outside of the new, smaller bounds will be "pushed" inward so that
     * th
     * 
     * @param worldDimensionInPixels
     */
    public synchronized void resizeWorldDimensionInPixels(int worldDimensionInPixels)
    {
        this.worldDimensionInPixels = worldDimensionInPixels;
        
        //
        // Get a valid value for the dimensions of the world.
        //
        if(worldDimensionInPixels < ConstantsSim2D.MinWorldWidthInPixels || worldDimensionInPixels > ConstantsSim2D.MaxWorldWidthInPixels) {
            this.worldDimensionInPixels = ConstantsSim2D.DefaultWorldWidthInPixels;
        }      
        
        this.setOuterWalls();
        this.replaceAllObjects();
    }
    
    /**
     * Get the world dimension in pixels.
     * 
     * @return  The world dimension in pixels.
     */
    public int getWorldDimensionInPixels()
    {
        return this.worldDimensionInPixels;
    }
    
    /**
     * Remove the old walls and create new outer walls based on the current
     * dimensions.
     */
    protected synchronized void setOuterWalls()
    {
        //
        // Remove the old outer walls.
        //
        Iterator<String> it = this.outerWallIDs.iterator();
        while(it.hasNext()) {
            this.removeObjectSim2D(it.next());
        }
        this.outerWallIDs.clear();
        
        //
        // Create new outer walls.
        //
        RectangularObstacleSim2D wallObject = null;
        
        
        // Left Wall
        AbsolutePositionSim2D leftWallPosition = new AbsolutePositionSim2D();        
        leftWallPosition.angleInRadians = 0;
        leftWallPosition.coordinates.x = ConstantsSim2D.DefaultOuterWallThicknessInPixels / 2;
        leftWallPosition.coordinates.y = this.worldDimensionInPixels / 2;
        
        wallObject = new RectangularObstacleSim2D(
                            leftWallPosition,
                            ConstantsSim2D.DefaultOuterWallThicknessInPixels,
                            this.worldDimensionInPixels);
        
        wallObject.setID("LEFT_WALL");
        this.addObjectSim2D(wallObject);
        this.outerWallIDs.add(wallObject.getID());
        

        // Right Wall
        AbsolutePositionSim2D rightWallPosition = new AbsolutePositionSim2D();                
        rightWallPosition.angleInRadians = 0;
        rightWallPosition.coordinates.x = this.worldDimensionInPixels - (ConstantsSim2D.DefaultOuterWallThicknessInPixels / 2);
        rightWallPosition.coordinates.y = this.worldDimensionInPixels / 2;
        
        wallObject = new RectangularObstacleSim2D(
                            rightWallPosition,
                            ConstantsSim2D.DefaultOuterWallThicknessInPixels,
                            this.worldDimensionInPixels);
        
        wallObject.setID("RIGHT_WALL");       
        this.addObjectSim2D(wallObject);
        this.outerWallIDs.add(wallObject.getID());
        
        
        // Top Wall
        AbsolutePositionSim2D topWallPosition = new AbsolutePositionSim2D();        
        topWallPosition.angleInRadians = 0;
        topWallPosition.coordinates.x = this.worldDimensionInPixels / 2;
        topWallPosition.coordinates.y = ConstantsSim2D.DefaultOuterWallThicknessInPixels / 2;
        
        wallObject = new RectangularObstacleSim2D(
                            topWallPosition,
                            this.worldDimensionInPixels,
                            ConstantsSim2D.DefaultOuterWallThicknessInPixels);
        
        wallObject.setID("TOP_WALL");
        this.addObjectSim2D(wallObject);
        this.outerWallIDs.add(wallObject.getID());
        
        
        // Bottom Wall
        AbsolutePositionSim2D bottomWallPosition = new AbsolutePositionSim2D();        
        bottomWallPosition.angleInRadians = 0;
        bottomWallPosition.coordinates.x = this.worldDimensionInPixels / 2;
        bottomWallPosition.coordinates.y = this.worldDimensionInPixels - (ConstantsSim2D.DefaultOuterWallThicknessInPixels / 2);
        
        wallObject = new RectangularObstacleSim2D(
                            bottomWallPosition,
                            this.worldDimensionInPixels,
                            ConstantsSim2D.DefaultOuterWallThicknessInPixels);
        
        wallObject.setID("BOTTOM_WALL");
        this.addObjectSim2D(wallObject);
        this.outerWallIDs.add(wallObject.getID()); 
    
    }
    
    /**
     * Iterate over all objects in the world and ensure that they fit within
     * the current world dimensions.  If they don't, they will be moved so
     * they do.  Outer walls will be ignored.
     */
    protected synchronized void replaceAllObjects()
    {
        List<String> removedObjectIDs = new ArrayList<String>();
        String currentID = null;
        Iterator<String> it = this.objects.keySet().iterator();
        while(it.hasNext()) {
            currentID = it.next();
            if(this.outerWallIDs.contains(currentID) == false) {
                removedObjectIDs.add(currentID);
            }
        }
        
        List<ObjectSim2D> removedObjects = new ArrayList<ObjectSim2D>();
        it = removedObjectIDs.iterator();
        while(it.hasNext()) {
            removedObjects.add(this.objects.remove(it.next()));
        }
        
        Iterator<ObjectSim2D> i = removedObjects.iterator();
        ObjectSim2D currentObject = null;
        while(i.hasNext()) {
            this.addObjectSim2D(i.next());
        }
        
    }
    
    
    /**
     * Collision handling.
     */
    
    /**
     * Checks for collisions and resolves them by adjusting object positions.
     */
    public synchronized void relax()
    {
        //
        // Resolve collisions with the immovable objects.
        //
        this.detectAndResolveCollisions(this.immovable, this.agents);
        this.detectAndResolveCollisions(this.immovable, this.movable);
        
        //
        // Next, resolve collisions between agents.
        //        
        this.detectAndResolveInternalCollisions(this.agents);
        
        //
        // Next, resolve collisions between the agents and the movable objects.
        //
        this.detectAndResolveCollisions(this.agents, this.movable);
        
        //
        // Finally, resolve collisions between movable objects.
        //
        this.detectAndResolveInternalCollisions(this.movable);        
    }    
    
    /**
     * Resolve collisions between two collections of ObjectSim2D objects.  This
     * method takes one Map of ObjectSim2D's as the "obstacles," and a second
     * as the "objects."  It iterates over the "obstacles," and if any "object"
     * collides, it moves the "object."  These two collections must be
     * disjoint sets of ObjectSim2D objects - that is, no object should
     * appear in both collections.  If you need to resolve collisions within a
     * single collection, use the <i>detectAndResolveInternalCollisions</i> method
     * instead.
     * 
     * @param   obstacles   [in]    Supplies the non-moving ObjectSim2D objects.
     * @param   objects     [in]    Supplies the movable ObjectSim2D objects.
     */
    protected synchronized void detectAndResolveCollisions(Map<String, ObjectSim2D> obstacles, Map<String, ObjectSim2D> objects)
    {
        Iterator<ObjectSim2D> obstacleIterator = obstacles.values().iterator();
        ObjectSim2D currentObstacle = null;
        Iterator<ObjectSim2D> objectIterator = null;
        ObjectSim2D currentObject = null;
        
        while(obstacleIterator.hasNext()) {
            currentObstacle = obstacleIterator.next();
            objectIterator = objects.values().iterator();
            while(objectIterator.hasNext()) {
                currentObject = objectIterator.next();
                if(currentObstacle.collidesWithObject(currentObject)) {
                    if(this.outerWallIDs.contains(currentObstacle.getID())) {
                        this.resolveCollisionWithOuterWall(currentObstacle, currentObject);
                    }
                    else {
                        this.resolveCollision(currentObstacle, currentObject);
                    }
                }
            }
        }
    }
    
    /**
     * Resolve a collision with an outer wall.  The standard method of
     * calculating the "out" angle won't always work here, because we always
     * want the "out" angle of an outer wall to be the same: pointing inwards
     * to the maze.
     * 
     * @param   outerWall   [in]    Supplies the outer wall.
     * @param   object      [in]    Supplies the colliding object.
     */
    protected synchronized void resolveCollisionWithOuterWall(ObjectSim2D outerWall, ObjectSim2D object)
    {
       double movementAngleInRadians = 0;
       
       if(outerWall.getID().equals("LEFT_WALL")) {
           movementAngleInRadians = (double) 0;
       }
       else if(outerWall.getID().equals("RIGHT_WALL")) {
           movementAngleInRadians = (double) Math.PI;
       }
       else if(outerWall.getID().equals("TOP_WALL")) {
           movementAngleInRadians = (double) Math.PI/2f;
       }
       else if(outerWall.getID().equals("BOTTOM_WALL")) {
           movementAngleInRadians = (double) -Math.PI/2f;
       }       
       else {
           throw new AssertionError("AgentWorldSim2D.resolveCollisionWithOuterWall:  The provided obstacle is not an outer wall.");
       }

        while(outerWall.collidesWithObject(object)) {
            object.translate(
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(movementAngleInRadians),
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(movementAngleInRadians));
        }
    }
    
    /**
     * Resolve a collision between two ObjectSim2D objects.  The first is
     * assumed to be the "obstacle," which will not move, and the second is the
     * "object," which will be moved.
     * 
     * @param   obstacle    [in]    Supplies the non-moving object.
     * @param   object      [in]    Supplies the object that will be moved.
     */
    protected synchronized void resolveCollision(ObjectSim2D obstacle, ObjectSim2D object)
    {
        double movementAngleInRadians = 0;
        int outcode;
        //
        // If somehow the center point of the object is within the bounding
        // box of the obstacle, the movement angle is the facing angle of the
        // obstacle (effectively, this "pushes" the object out of the obstacle
        // in the direction of the obstacle's facing).
        //
        if(obstacle.getBoundingBox().contains(object.getCenterPoint())) {
            movementAngleInRadians = obstacle.getAngle();
        }
        
        //
        // Otherwise, the movement angle is calculated based on where the
        // center point of the object lies relative to the obstacle's bounding
        // box.
        //
        else {
            outcode = obstacle.getBoundingBox().outcode(object.getCenterPoint());
            movementAngleInRadians = CollisionConstants.GetOutAngle(outcode);            
        }
        
        object.translate(
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(movementAngleInRadians),
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(movementAngleInRadians));
        
        /*
        while(obstacle.collidesWithObject(object) || object.collidesWithObject(obstacle)) {
            object.translate(
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(movementAngleInRadians),
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(movementAngleInRadians));
        }
         */ 
    }
    
    /**
     * This method resolves collisions among a collection of ObjectSim2D
     * objects.  It is assumed that if two objects collide that both should be
     * moved.
     * 
     * @param   objects     [in]    Supplies the objects.
     */
    protected synchronized void detectAndResolveInternalCollisions(Map<String, ObjectSim2D> objects)
    {
        Iterator<ObjectSim2D> obstacleIterator = objects.values().iterator();
        ObjectSim2D currentObstacle = null;
        Iterator<ObjectSim2D> objectIterator = null;
        ObjectSim2D currentObject = null;
        while(obstacleIterator.hasNext()) {
            currentObstacle = obstacleIterator.next();
            objectIterator = objects.values().iterator();
            while(objectIterator.hasNext()) {
                currentObject = objectIterator.next();
                if(currentObject != currentObstacle) {
                    if(currentObstacle.collidesWithObject(currentObject)) {
                        this.resolveInternalCollision(currentObstacle, currentObject);
                    }
                }
            }
        }
    }
    
    /**
     * This method resolves collisions between two ObjectSim2D world objects
     * where both objects will move.  The current implementation finds the
     * center point bewteen the bounding box center points of each object,
     * calculates the angle of each objects' center from that point, and moves
     * both objects away from each other at those specified angles until their
     * bounding boxes no longer intersect.
     * 
     * @param   o1      [in]    Supplies the first object.
     * @param   o2      [in]    Supplies the second.
     */
    protected synchronized void resolveInternalCollision(ObjectSim2D o1, ObjectSim2D o2)
    {
        if(o1 instanceof GrippableSim2D && ((GrippableSim2D)o1).isGripped()) {
            if(o2 instanceof GrippableSim2D && ((GrippableSim2D)o2).isGripped()) {
                resolveInternalCollision(
                            ((GrippableSim2D)o1).getGripper().getAgent(),
                            ((GrippableSim2D)o2).getGripper().getAgent());
                return;
            }
            else {
                this.resolveCollision(o1, o2);
                return;
            }
        }
        
        if(o2 instanceof GrippableSim2D && ((GrippableSim2D)o2).isGripped()) {
            this.resolveCollision(o2, o1);
            return;        
        }
        
        double o1MovementAngleInRadians = CollisionConstants.GetVectorAngleInRadians(o2.getCenterPoint(), o1.getCenterPoint());
        double o2MovementAngleInRadians = CollisionConstants.GetVectorAngleInRadians(o1.getCenterPoint(), o2.getCenterPoint());
        
        if(o1MovementAngleInRadians == o2MovementAngleInRadians) {
            o1MovementAngleInRadians += 0.1;
        }
        
        o1.translate(
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(o1MovementAngleInRadians),
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(o1MovementAngleInRadians));    
        
        o2.translate(
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(o2MovementAngleInRadians),
                ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(o2MovementAngleInRadians));        
        
        /*
        while(o1.collidesWithObject(o2) || o2.collidesWithObject(o1)) {
           
            
            o1.translate(
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(o1MovementAngleInRadians),
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(o1MovementAngleInRadians)); 
            
            
            o2.translate(
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.cos(o2MovementAngleInRadians),
                    ConstantsSim2D.CollisionNudgeInPixels * (double) Math.sin(o2MovementAngleInRadians));  
            
            o1MovementAngleInRadians = CollisionConstants.GetVectorAngleInRadians(o2.getCenterPoint(), o1.getCenterPoint());
            o2MovementAngleInRadians = CollisionConstants.GetVectorAngleInRadians(o1.getCenterPoint(), o2.getCenterPoint());
        
            if(o1MovementAngleInRadians == o2MovementAngleInRadians) {
                o1MovementAngleInRadians += 0.1;
            }            
        }
         */ 
    }
    
    /**
     * Thread methods.
     */
    
    /**
     * Start the world running.  This starts the update thread.
     */
    public void start()
    {
        this.stopRequested = false;
        this.updateThread = new Thread(this);
        this.updateThread.start();
    }
    
    /**
     * Stop the world running.  This stops the update thread.
     */
    public void stop()
    {
        this.stopRequested = true;
        try {
            this.updateThread.join();
        }
        catch(InterruptedException e) {
            return;
        }
        this.updateThread = null;
    }    
    
    /**
     * Set the number of updates per second.
     * 
     * @param   updatesPerSecond    [in]    Supplies the number of updates per
     *                                      second.
     */
    public void setUpdatesPerSecond(int updatesPerSecond)
    {
        if(updatesPerSecond < ConstantsSim2D.MinUpdatesPerSecond || updatesPerSecond > ConstantsSim2D.MaxUpdatesPerSecond) {
            throw new AssertionError("AgentWorldSim2D.setUpdatesPerSecond():  Desired update rate out of bounds.");
        }
        
        this.updateDurationInMillis = 1000 / updatesPerSecond;
    }
    
    /**
     * Overrides <i>Runnable.run()</i>.  
     */
    public void run()
    {
        //
        // Declare the iterator and object used in the update loop.
        //
        Iterator<ObjectSim2D> it = null;
        ObjectSim2D currentObject = null;
        
        //
        // The update loop:
        //
        while(this.stopRequested == false) {
            //
            // Update all active objects.
            //
            it = this.objects.values().iterator();
            while(it.hasNext()) {
                currentObject = it.next();
                if(currentObject instanceof ActiveSim2D) {
                    ((ActiveSim2D)currentObject).update(this.objects, this.updateDurationInMillis);
                }
            }
            
            //
            // Resolve collisions.
            //
            this.relax();
            
            //
            // Sleep for the Updates Per Second interval
            //
            try {
                Thread.sleep(this.updateDurationInMillis);
            }
            catch(InterruptedException e) {
                
            }
            
        }
    }

    
    /**
     * View methods.
     */
    
    /**
     * Get the initial view update.
     * 
     * @return  The initial view update.
     */
    public ContextViewUpdate getInitialViewSync()
    {
        return this.getInitialSyncPayload();
    }
    
    /**
     * Get the update for the visuallzation of the world.
     * 
     * @return  The update.
     */
    public ContextViewUpdate getViewUpdate()
    {
        return this.getCurrentPayload();
    }  
    
    /**
     * Get copies of all the Drawable objects (so the remote view knows what
     * to draw).
     * 
     * @return  An Sim2DGraphicsInitializer message payload.
     */
    public synchronized Sim2DGraphicsInitializer getInitialSyncPayload()
    {
        Sim2DGraphicsInitializer payload = new Sim2DGraphicsInitializer();
        
        Iterator<ObjectSim2D> it = this.objects.values().iterator();
        DrawableObjectSim2D currentObject = null;
        while(it.hasNext()) {
            currentObject = it.next().getDrawable();
            payload.drawableObjects.add(currentObject);
        }
        
        return payload;
    }    
    
    /**
     * Get the current Sim2DGraphicsUpdate that represents the current state of the
     * sim world.
     * 
     * @return  The current view update.
     */
    public synchronized Sim2DGraphicsUpdate getCurrentPayload()
    {
        Sim2DGraphicsUpdate newUpdate = new Sim2DGraphicsUpdate();
        //
        // Iterate over all the stuff in the world, get position and ID, and
        // add it to the viewUpdate.
        //
        Iterator<ObjectSim2D> it = this.objects.values().iterator();
        ObjectSim2D currentObject = null;
        Object currentDrawableUpdate = null;
        while(it.hasNext()) {
            currentObject = it.next();
            currentDrawableUpdate = currentObject.getDrawableUpdate();
            if(currentDrawableUpdate != null) {
                newUpdate.updates.put(currentObject.getID(), currentDrawableUpdate);
            }
        }
        
        return newUpdate;
    }
}
